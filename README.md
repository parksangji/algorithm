# 알고리즘(Algorithm)

* * *
> ## 1.퀵 정렬 (quick sort) 


>> #### 분할정복 패러다임을 기반으로 한 정렬 알고리즘이다. 각 부분수열의 맨 처음에 있는 수를 기준으로 삼는다. 기준보다 작은 수를 왼쪽으로, 큰 수를 오른 쪽으로 가게끔 수열을 분해한다.

>> #### 시간 복잡도 : 최악의 경우 시간복잡도는 O(N^2)이 되지만, 평균적으로 부분 문제가 절반에 가깝게 나누어질 경우 시간복잡도는 O(nlog(n))이 된다.

* * *

> ## 2.선택 정렬 (selection sort)


>> #### 배열에서 최소값을 찾는다. 그 다음에 찾은 최소값을 맨 앞의 요소와 바꿔준다. 맨 앞을 제외한 값들에서 최소값을 찾고 위와 같은 방법으로 교체해준다.

>> #### 시간 복잡도 : N개의 요소가 있다고 가정하에 첫번째 자리에 올 요소를 찾기 위해서 N개의 요소를 탐색한다. 그 다음 두번째 자리에 올 요소를 탐색하려면 N-1개의 요소를 탐색한다. 세번째는 N-2, 네번째는 N-3 ... 이 탐색 시간을 모두 더하면 시간 복잡도는 O(N^2)가 된다. 다른 정렬 알고리즘에 비해 구현이 간단하지만 성능이 좋지 않은 알고리즘이다.

> ## 3.버블 정렬 (bubble sort)

>> #### 매번 연속된 두 개의 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법이다. 오름차순으로 정렬하고자 할경우, 비교시마다 큰 값이 뒤로 이동하여, 1바귀 돌 시 가장 큰 값이 맨 뒤에 저장된다. 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장되기 때문에 전체 배열의 크기에서 현재까지 순환한 바퀴 수의 차이 만큼만 반복해 주면된다.

>> #### 시간 복잡도 : 선택정렬과 동일하고 1부터 비교를 시작하여, N-1, N-2 ... 씩 비교를 하며, 총 시간 복잡도는 O(N^2)을 갖는다.

> ## 4.합병 정렬 (merge sort)

>> #### 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

>> #### 시간 복잡도 : 합병 정렬의 Divide 단계에서 분할 되는 깊이가 log(N)이다. 각 깊이별로 Divide가 수행되어 합병해야되는 배열의 수는 많아지지만, 총 원소의 수와 똑같다. 따라서 각 깊이 별로 수행되는 merge의 시간복잡도는 O(N)이 된다. 모든 깊이에 대해(log(N)개 만큼) 수행하기 때문에 시간 복잡도는 O(N*log(N))이 된다.
